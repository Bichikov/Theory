# oglavlenie
1. [Начало работы с PHP.](#1)
1. [Ввод и вывод данных.](#2)
    + [Вывод данных.](#2-1)
1. [Коментарии.](#3)
1. [Переменные.](#4)
    + [Числа](#4-0)
    + [Строки](#4-1)
    + [Логические значения в PHP](#4-2)
    + [Значение null в PHP](#4-3)
1. [Работа с HTML тегами в PHP](#5) 
    + [Атрибуты тегов](#5-1)
1. [Автоматическое преобразование типов в PHP](#6)
    + [Преобразование к строке](#6-1)
1. [Массивы](#7)
    + [Создание массива.](#7-1)
    + [Вывод массива.](#7-2)
	+ [Ассоциативные массивы](#7-3)
		+ [Хитрость с ключами](#7-3-1)
	+ [Длина массива](#7-4)
	+ [Изменение элементов массива.](#7-5)
8. [Операции инкремента и декремента.](#8)
9. [Арифметические операции](#9)

# 1. 
# Начало работы с PHP.
[Оглавление](#oglavlenie)

# 2. 
# Ввод и вывод данных.
## 2-1.
## Вывод данных.
[Оглавление](#oglavlenie)

*Команда* *`echo`* командует вывести что-нибудь на экран. 
+ Давайте `выведем` какую-нибудь `строку:`
```
<?php
	echo 'hello';
?>
```
+ Давайте `выведем `какое-нибудь `число:`
```
<?php
	echo 123;
?>
```

*Команда* *`echo`* не всегда дает представление о том, что мы выводим. Для отладки ваших программ лучше использовать специальную `функцию var_dump.` Она помимо вывода строки или числа еще будет указывать `тип выводимых данных,` а также `их размер:`
```
<?php
	var_dump('12345'); // выведет '12345' и еще некоторую 
		полезную инфу 
?>
```
+ На примере `var_dump` мы сталкиваемся с функциями. Они позволяют выполнять некоторые действия. `Функция` `состоит` из имени и круглых скобок, написанных после этого имени. В этих круглых скобках следует писать `параметры функции.` В нашем случае параметром является текст, который выводится на экран. Бывают функции, в которые нужно передавать не один параметр, как у нас сейчас, а несколько параметров. В этом случае эти параметры пишутся через запятую.

+ `Отделить` в выводе `строку от строки` можно вот так: 
```
<?php
    echo '<br>';
	echo $arr[0] . "<br>";
?>
```

# 3.
# Комментарии.
[Оглавление](#oglavlenie)

Подобно языкам HTML и CSS в языке PHP можно оставлять комментарии. Они бывают `однострочными и многострочными.`

+ Вот пример `однострочного` комментария:
```
<?php
	echo 'hello'; // комментарий
?>
```
+ Вот пример `многострочного` комментария:
```
<?php
	/*
		комментарий
		комментарий
	*/
	echo 'hello';
?>
```

# 4.
# Переменные.
[Оглавление](#oglavlenie)
+ Основным понятием любого языка программирования является `переменная.` Переменная представляет собой контейнер, в котором мы можем хранить какие-либо данные, например, строки или числа.

+ Каждая переменная должна иметь имя, которое может состоять `из латинских букв`, `чисел и знаков подчеркивания`. При этом в PHP `перед` переменной обязательно должен быть написан знак доллара `$`, а первый символ имени переменной не должен быть цифрой.
## 4-0
## Числа
[Оглавление](#oglavlenie)

**`Целые числа`** :
+ Пусть, к примеру, у нас `есть строка с цифрами`:
```
<?php
	$test = '1';
	var_dump($test);
?>
```
+ Давайте `преобразуем ее в целое число`. Для этого используем специальную команду int, вот так:
```
<?php
	$test = (int) '1';
	var_dump($test); // выведет 1 - число
?>
```
+ Можно воспользоваться `командой преобразования прямо в вызове функции:`
```
<?php
	var_dump((int) '1');
?>
```
+ `Можно преобразовать` значение переменной:
```
<?php
	$test = '1';
	var_dump((int) $test);
?>
```
**`Дробные числа`** :
+ Пусть теперь у нас есть строка с дробным числом:
```
<?php
	$test = '1.2';
	var_dump($test);
?>
```
+ Для `преобразования этой строки` в число следует воспользоваться `командой float:`
```
<?php
	$test = (float) '1.2';
	var_dump($test); // выведет 1.2
?>
```
## 4-1
## Строки.
[Оглавление](#oglavlenie)
+ Строки создаются с помощью кавычек:

```
<?php
	$str = 'abc';
	echo $str; // выведет 'abc'
?>
```
+ Кавычки могут быть не только одинарными, но и двойными:
```
<?php
	$str = "abc";
	echo $str; // выведет 'abc'
?>
```

**`СЛОЖЕНИЕ СТРОК`** :
+ Для `сложения` `(конкатенации)` строк используется оператор точка:
```
<?php
	$str = 'abc' . 'def'; // складываем две строки
	echo $str;            // выведет 'abcdef'
?>
```
+ Строки также могут хранится в переменных:
```
<?php
	$str1 = 'abc';
	$str2 = 'def';
	echo $str1 . $str2; // выведет 'abcdef'
?>
```
+ Можно также складывать переменные и строки:
```
<?php
	$str1 = 'abc';
	$str2 = 'def';
	echo $str1 . '!!!' . $str2; // выведет 'abc!!!def'
?>
```

**`ДЛИНА СТРОК`** :
+ Количество символов строки можно найти с помощью функции `strlen:`
```
<?php
	echo strlen('abcde'); // выведет 5
?>
```
+ Строка может хранится и в переменной:
```
<?php
	$str = 'abcde';
	echo strlen($str); // выведет 5
?>
```
+ `Пробел` также является символом:
```
<?php
	echo strlen('ab de'); // выведет 5
?>
```

+ Можно также `преобразовать число к строке:`
```
<?php
	$test = (string) 123;
	var_dump($test); // выведет '123'
?>
```
+ Аналогичным образом будет работать `преобразование дробного числа:`
```
<?php
	$test = (string) 1.2;
	var_dump($test); // выведет '1.2'
?>
```

**`Проблема с кириллицей`** :
+ Функция `strlen()`, как и многие другие строковые функции PHP, некорректно работает с кириллицей - она каждую `кириллическую букву` `считает два раза:`
```
<?php
	echo strlen('абвгд'); // выведет 10, а не 5
?>
```
+ Поэтому для строк, которые содержат или потенциально могут содержать проблемные символы, используйте функцию `mb_strlen()` - она будет работать корректно:
```
<?php
	echo mb_strlen('абвгд'); // выведет 5
?>
```
## 4-2
## Логические значения в PHP:
[Оглавление](#oglavlenie)
+ Кроме чисел и строк существует еще один тип данных - `логический (boolean)`. Он состоит всего из двух возможных значений: `true или false`. Эти значения обозначают истину и ложь соответственно.

+ Логический тип данных используется для таких вещей, которые предполагают два варианта ответа - да или нет. К примеру, на вопрос "вам уже есть 18 лет?" в можете ответить да, то есть `true, или нет, то есть false.`

+ Давайте посмотрим `на примере:`
```
<?php
	$isAdult = true;  // уже взрослый
?>
```
+ Поменяем значение на другое:
```
<?php
	$isAdult = false; // еще не взрослый
?>
```
+ Выведем значение нашей переменной на экран. Используем для этого специальную функцию `var_dump:`
```
<?php
	$isAdult = true;
	var_dump($isAdult); // выведет true
?>
```
+ А вот через `echo` выводить логические значения не удобно:
```
<?php
	echo true;  // выведет 1
	echo false; // выведет пустоту
?>
```
## 4-3
## Значение null в PHP
[Оглавление](#oglavlenie)
+ В PHP существует еще одно специальное значение `null,` которое обозначает `"ничего"`. К примеру, мы можем присвоить переменной это значение в знак того, что там ничего не лежит.

+ Давайте посмотрим `на примере`:
```
<?php
	$test = null;
?>
```
+ Выведем значение нашей переменной `с помощью` `var_dump`:
```
<?php
	$test = null;
	var_dump($test); // выведет null
?>
```
+ А вот через `echo` мы ничего не увидим:
```
<?php
	$test = null;
	echo $test;      // выведет пустоту
?>
```
+ По умолчанию переменные, которые не были объявлены в коде, имеют значение `null`:
```
<?php
	var_dump($test); // выведет null
?> 
```

# 5
# Работа с HTML тегами в PHP
[Оглавление](#oglavlenie)
+ Теги HTML с точки зрения PHP представляют собой обычные строки. 
+ Давайте, например, с помощью тега `<b>` выведем на экран жирный текст:
```
<?php
	echo '<b>жирный</b>';
?>
```
+ Можно использовать `несколько echo:`
```
<?php
	echo '<b>';
	echo 'жирный';
	echo '</b>';
?>
```
+ Можно использовать `конкатенацию:`
```
<?php
	$str = 'жирный';
	echo '<b>' . $str . '</b>';
?>
```
+ `Или` вот так:
```
<?php
	$str   = 'жирный';
	$open  = '<b>';
	$close = '</b>';
	
	echo $open . $str . $close;
?>
```

## 5-1
## Атрибуты тегов
[Оглавление](#oglavlenie)
+ Давайте с помощью тега `<a>` выведем на экран ссылку:
```
<?php
	echo '<a href="index.php">ссылка</a>';
?>
```
+ Пусть теперь `адрес и текст` ссылки хранятся в `отдельных переменных`:
```
<?php
	$href = 'index.php';
	$text = 'ссылка';
	
	echo '<a href="' . $href . '">' . $text . '</a>';
?>
```
## 6 
## Автоматическое преобразование типов в PHP
[Оглавление](#oglavlenie)
+ Как вы уже знаете, строки в PHP следует брать в кавычки. Может быть такое, что всеми символами строки будут являться цифры. В этом случае, если над строкой с цифрами выполнить какую-либо математическую операцию - эта операция будет выполнена так, будто у нас действительно числа, а не строки:
```
<?php
	echo '1' + '2'; // выведет 3
?>
```
+ В данном случае `PHP видит`, что мы пытаемся выполнить `недопустимую для строк`, но `допустимую` `для чисел` операцию. Он также видит, что фактически наши строки - это числа в кавычках. Поэтому PHP автоматически выполняет преобразование этих строк к чисел и выполняет соответствующую математическую операцию над ними.

+ `Аналогичным` образом будет происходить сложение `строки с цифрами` и обычного числа:
```
<?php
	echo '1' + 2;   // выведет 3
?>
```
+ При этом не будет иметь значения, в каком порядке выполнять сложение:
```
<?php
	echo 1 + '2';   // выведет 3
?>
```
+ `Все сказанное` будет аналогичным образом работать и `для переменных`:
```
<?php
	$a = '1';
	$b = '2';
	
	echo $a + $b;   // выведет 3
?>
```
## 6-1 
## Преобразование к строке
[Оглавление](#oglavlenie)
+ `Аналогичное преобразование будет происходить с числами`, над которыми мы пытаемся выполнить операцию, разрешенную только для строк:
```
<?php
	echo 1 . 2;    // выведет '12'
?>
```
+ `Но тут есть нюансы.` Точка используется не только для сложения строк, но и для отделения дробной части от целой. Поэтому, если в нашем коде убрать пробелы вокруг точки, мы получим дробь, а не сложение строк:
```
<?php
	echo 1.2;     // выведет 1.2
?>
```
+ `Из-за таких нюансов можно легко получить ошибку,` если с одной стороны точки поставить пробел, а с другой - нет:
```
<?php
	echo 1. 2;    // выдаст ошибку
?>
```
+ `С переменными`, однако, такой `проблемы не будет`:
```
<?php
	$a = '1';
	$b = '2';
	
	echo $a.$b;   // выведет 12, а не ошибку
?>
```

# 7.
# Массивы. 

## 7-1 
## Создание массива.
[Оглавление](#oglavlenie) 
+ Для `создания массива` используются `квадратные скобки (1):`
```
<?php
	$arr = []; // создаем массив $arr
?>
```
**`ИЛИ(2)`**

```
<?php
    $arr = array(1,2,3,4,5); // создаем массив $arr
?>
```
**`ИЛИ(3)`**
```
<?php
	$var = "php - 7";
	$arr3 =(array) $var;
?>
```

+ Элементы в массив не обязательно добавлять сразу в момент объявления этого массива. `Можно вначале объявить этот массив пустым`, а затем добавить в него необходимые элементы, вот так:
```
?php
	$arr = [];     // создаем пустой массив
	
	$arr[] = 'a';  // элемент добавится в ключ 0
	$arr[] = 'b';  // элемент добавится в ключ 1
	$arr[] = 'c';  // элемент добавится в ключ 2
	
	var_dump($arr); // выведет ['a', 'b', 'c']
?>
```
+ Массив не обязательно должен быть изначально пустым - `там уже что-то может быть`, но мы все равно можем добавлять новые элементы:
```
<?php
	$arr = ['a', 'b', 'c']; // объявляем массив с элементами
	
	$arr[] = 'd'; // элемент добавится в ключ 3
	$arr[] = 'e'; // элемент добавится в ключ 4
	
	var_dump($arr); // выведет ['a', 'b', 'c', 'd', 'e']
```
## 7-2
## Вывод массива
[Оглавление](#oglavlenie)
+ Для того, чтобы PHP вывел нам все элементы массива, нужно воспользоваться функцией `var_dump :`
```
$a = [1, 2, 3];
var_dump($a);
```
+ `ИЛИ` способ через `print_r()`:
```
<?php
    $a = [1, 2, 3];
    echo '<pre>';
    print_r($a);
    echo '</pre>';  
?>
```

## 7-3.
## Ассоциативные массивы.
[Оглавление](#oglavlenie)

+ Логичнее и удобнее было бы все-таки для первого дня недели писать ключ 1, как привыкли мы в жизни. Для этого используются `ассоциативные массивы.` Они имеют следующий синтаксис: `имя ключа, затем идет стрелка =>`, а потом `значение`. Давайте укажем явные ключи для нашего массива дней:
```
<?php
	$arr = [1 => 'пн', 2 => 'вт', 3 => 'ср', 4 => 'чт', 5 => 'пт', 6 => 'сб', 7 => 'вс'];
?>
```
+ Как вы уже знаете, в обычных массивах элементы располагаются в строгом порядке, ведь позиция каждого элемента определяет его ключ. `В ассоциативных массивах` мы сами назначаем ключи, поэтому `порядок следования элементов` не имеет значения.

+ Если переставить элементы этого массива в произвольном порядке (конечно же, вместе с их ключами), то ничего от этого в работе нашего скрипта не изменится

+ Кроме того, `числовые ключи` не обязательно должны иметь все значения `без дырок`. У нас могут быть произвольные числа и это не будет приводить ни к каким проблемам:
```
<?php
	$arr = [7 => 'value1', 50 => 'value2', 23 => 'value3'];
?>
```
## 7-3-1
## Хитрость с ключами.
[Оглавление](#oglavlenie)
+ Не очень удобно расставлять ключи всем элементам для того, чтобы нумерация `началась не с нуля`, а с единицы. К счастью, на самом деле достаточно `первому элементу `поставить ключ 1 и дальше `PHP` сам `автоматически` расставит ключи по порядку.

Давайте попробуем:
```
<?php
	$arr = [1 => 'пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'];
	
	echo $arr[1]; // выведет 'пн'
	echo $arr[2]; // выведет 'вт'
	echo $arr[3]; // выведет 'ср'
?>
```
+ `Ключи` не обязательно должны быть числами, они `могут быть и строками`.

# 7-4
# Длина массива.
[Оглавление](#oglavlenie)

+ `Длина массива` находится с помощью функции `count()`:
```
<?php
	$arr = [1, 2, 3];
	echo count($arr); // выведет 3
?>
```
# 7-5
# Изменение элементов массива.
[Оглавление](#oglavlenie)
+ `Элементы массивов` можно изменять подобно изменению символов строки:
```
<?php
	$arr = ['a', 'b', 'c'];
	
	$arr[0] = '!';
	var_dump($arr); // выведет ['!', 'b', 'c']
?>
```

+ `Перезапись элементов`

Можно также прочитывать текущее значение элемента, выполнять с ним какие-то операции и записывать измененное значение обратно в этот элемент:
```
<?php
	$arr = ['a', 'b', 'c'];
	
	$arr[0] .= '!';
	$arr[1] .= '!';
	$arr[2] .= '!';
	
	var_dump($arr); // выведет ['a!', 'b!', 'c!']
?>
```

# 8
# Операции инкремента и декремента.
[Оглавление](#oglavlenie)
+ На самом деле `операции инкремента и декремента `можно записывать двумя способами. В `постфиксном` виде операция записывается после имени переменной, `вот так: $a++`, а в `префиксном виде` - перед именем переменной, `вот так: ++$a.` Давайте посмотрим на примерах, в чем разница между двумя способами.

+ В следующем примере первый echo выведет 0, так как `вначале сработает вывод на экран`, а уже затем переменная увеличится:
```
<?php
	$num = 0;
	echo $num++; // выведет 0, тк переменная увеличится только после 
		echo 
	echo $num;   // выведет 1 - переменная поменялась
?>
```
+ А теперь `переменная вначале увеличится`, а уже затем будет вывод на экран:
```
<?php
	$num = 0;
	echo ++$num; // выведет 1 - переменная увеличилась сразу
?>
```
+ А теперь `поменяем `постфиксную форму на префиксную:
```
<?php
	$num1 = 0;
	$num2 = ++$num1; // в переменную $num2 запишется 1
	echo $num2;      // выведет 1
?>
```
+ Если наша `операция выполняется на отдельной строке`, то `разницы` между префиксной и постфиксной формами `нет`:
```
<?php
	$num = 0;
	++$num;
	$num++;
	echo $num; // выведет 2
?>
```
# 9 
# Арифметические операции 
[Оглавление](#oglavlenie)
+ `.` - это конкатенация
+ `+` - это сложение.
+ `-` - это вычитание. 
+ `*` - это умножение.
+ `/` - это деление (по умолчанию в вещ. числах).
+ `%` - это остаток от деления.
    + Если у нас делимое < делителя, то в остатке будет делимое. 
    + при нахождении остатка от деления на целое число `n` может получаться результат `0, 1, 2, ...n-1`, то есть к примеру при делении на `3` остатки `(0, 1, 2)`
+ `**` - это возведение в степень.

1. `$arr[0] .= '!';` - это `$arr[0] = $arr[0] . '!';`
1. `$i = 2`
2. `$i += 3` - это `$i = $i + 3`
3. `$i -= 4` - это `$i = $i - 4`
4. `$i *= 5` - это `$i = $i * 5`
5. `$i /= 5` - это `$i = $i / 5`
6. `$i //= 5` - это `$ = $i // 5`
7. `$i %= 5` - это `$i = $i % 5`
8. `$i **= 5` - это `$i = $i ** 5`
