# Python синтаксис.
## Oglavlenie:
1. [Начало работы с пайтон.](#1)
1. [Ввод и вывод данных.](#2)
    + [Вывод данных.](#2-1)
    + [Sep end для вывода.](#2-2)
    + [Ввод данных.](#2-3)
1. [Переменные.](#3)
1. [Базовые типы данных.](#4)
    + [Целые числа.](#4-1)
    + [Вещественные числа.](#4-2)
    + [Логический тип.](#4-3)
    + [Строчный тип.](#4-4)
        + [Срезы в строках.](#4-4-1)
        + [Конкатенация строк.](#4-4-2)
        + [Умножение строки на число.](#4-4-3)
        + [Примечания.](#4-4-4)
        + [Методы в строках.](#4-4-5)
            1. [Конвертация регистра.](#4-4-5-1)
                +  [Метод `capitalize()`](#4-4-5-1-1)
                +  [Метод `swapcase()`](#4-4-5-1-2)
                +  [Метод `title()`](#4-4-5-1-3)
                +  [Метод `lower()`](#4-4-5-1-4)
                +  [Метод `upper()`](#4-4-5-1-5)
                +  [Примечание](#4-4-5-1-6)
            2. [Поиск и замена](#4-4-5-2)
                + [Метод `count()`](#4-4-5-2-1)
                + [Метод `startswith()`](#4-4-5-2-2)
                + [Метод `endswith()`](#4-4-5-2-3)
                + [Методы `find(), rfind()`](#4-4-5-2-4)
                + [Методы `index(), rindex()``](#4-4-5-2-5)
                + [Метод `strip()`](#4-4-5-2-6)
                + [Метод `lstrip()`](#4-4-5-2-7)
                + [Метод `rstrip()`](#4-4-5-2-8)
                + [Метод `replace()`](#4-4-5-2-9)
            3. [Классификация символов](#4-4-5-3)
                + [Метод `isalnum()`](#4-4-5-3-1)
                + [Метод `isalpha()`](#4-4-5-3-2)
                + [Метод `isdigit()`](#4-4-5-3-3)
                + [Метод `islower()`](#4-4-5-3-4)
                + [Метод `isupper()`](#4-4-5-3-5)
                + [Метод `isspace()`](#4-4-5-3-6)
1. [Комментарии.](#5)
1. [Интерпаляция.](#6)
1. [Приведение типов.](#7)
1. [Арифметические операции.](#8)
1. [Алгоритм получения цифр n-значного числа.](#9)
1. [Логичесие операции](#10)
    + [Приоритет логических операций.](#10-1)
    + [Цепочки сравнений](#10-2)
1. [Округление числел](#11)
1. [if, else, elif, while.](#12)
    + [Оператор прерывания цикла break](#12-1)
    + [Бесконечные циклы](#12-2)
    + [Оператор continue](#12-3)
1. [Цикл for](#13)
    + [Цикл for в строках](#13-1)
1. [Функции](#14)
    + [Функции min и max.](#14-1)
    + [Функция abs.](#14-2)
    + [Модуль MATH.](#14-3)
        + [Список наиболее часто используемых функций модуля math.](#14-3-1)
    + [Модуль random](#14-4)
1. [Списки](#15)
    + [Основные действия со списками](#15-1)
1. [Кортежи](#16)
1. [Словари](#17)
    + [Создание словаря с помощью функции dict()](#17-1)
    + [Создание словаря на основании списков и кортежей](#17-2)
    + [fromkeys()](#17-3)
    + [Пустой словарь](#17-4)
    + [Примечания](#17-5)
    + [Ключи должны быть уникальными](#17-6)
    + [Ключи должны быть неизменяемым типом данных](#17-7)
    + [Функция len()](#17-8)
    + [Оператор принадлежности in](#17-9)
    + [Встроенные функции sum(), min(), max()](#17-10)
    + [Сравнение словарей](#17-11)
    + [Примечание](#17-12)
1. [Множества](#18)
    + [Операции со множествами в Python.](#18-1)
    + [Обобщение свойств встроенных коллекций в сводной таблице](#18-2)
1. [List Comprehension.](#list-comprehension)
1. [Примеры кода.](#20)
    + [Подсчет количества.](#20-1)
    + [Вычисление суммы и произведения.](#20-2)
    + [Обмен значений переменных](#20-3)
    + [Сигнальные метки.](#20-4)
    + [Максимум и минимум.](#20-5)

## 1. 
# Начало работы с python.
[Оглавление](#oglavlenie)
1. Заходим на официальный сайт языка и скачиваем последнюю версюю интерпретатора.

2. После утановки открываем терминал и пишеи `python3 --version`.
Должна высветится версия питона которая установлена.
3. Далее в `visual studio code` скчиваем расширение `python`.
4. Расширение для `python` это `.py`.
5. Виртуальное окуружение python3 -m venv .folder
Высветится что мы добавили расширение -> нажимем "yes".
6. Запуск программы на питоне либо (нажимаем на стрелоку) либо (пишем в консоль `python название файла.py`)

## 2. 
# Ввод и вывод данных. 

[Оглавление](#oglavlenie)
### 2-1.
## Вывод данных.
[Оглавление](#oglavlenie)

Значения для вывода, указываемые через запятую в команде print(1, 2 ,3), называются - аргументами или параметрами.
```
    print('Hello World') и print("Hello World")
``` 
Выведет одно и тоже (без разницы какие ковычки), если в тексте нужны одинарные кавычки, то для обрамления такого текста используем двойные кавычки ,если в тексте нужны двойные кавычки, то обрамляем его одинарными.
```
    print() - пустая строка.
    print('1', '2', '4', '8', '16')
```
+ при написании кода, между аргументами команды print() после запятой мы ставим 1 символ пробел. Это общепринятое соглашение в языке Python. Этот символ пробела не влияет на вывод данных.

## 2-2.
## Sep, end для вывода.

[Оглавление](#oglavlenie)
+ `sep` - Это separator(разделитель).
```
print('a', 'b', 'c', sep='*')
print('d', 'e', 'f', sep='**')
    Вывод:
a*b*c
d**e**f
```
+ `end` - Это окончание. Если перевод строки не нужно или требуется указать специальное окончание, то следует явно указать значение для параметра end.
```
print('a', 'b', 'c', end='@')
print('d', 'e', 'f', end='@@')
    Вывод: 
a b c@d e f@@
```
Пример: 
```
print('a', 'b', 'c', sep='*', end='finish')
print('d', 'e', 'f', sep='**', end='^__^')
print('g', 'h', 'i', sep='+', end='%')
print('j', 'k', 'l', sep='-', end='#')
print('m', 'n', 'o', sep='/', end='!')
    Вывод:
a*b*cfinishd**e**f^__^g+h+i%j-k-l#m/n/o!
```
+ `end='/n'` - перервод строки (по умолчанию и без команды)
+ `sep='пробел'` - пробел(по умолчанию и без команды)

+ Чтобы убрать все дополнительные выводимые символы, можно вызывать команду print() так:
```
print('a', 'b', 'c', sep='', end='')
```
+ Если после вывода данных нужно более одного перевода строки, то необходимо использовать следующий код: 
```
print('Python', end='\n\n\n')
```
## 2-3. 
## Ввод данных.

[Оглавление](#oglavlenie)

    input() - запрос ввода у пользователя

Пример:

    a = input('Введите число: ') - можно не использовать `print` перед переменной и приглашать пользоваетля ввести число, а написать все в одной строчке.

    print(a)
## 3.
# Переменные:

[Оглавление](#oglavlenie)
+ В языке Python можно за одну инструкцию присваивания изменять значение сразу нескольких переменных. Делается это так:
```
name, surname = 'Timur', 'Guev'
print('Имя:', name, 'Фамилия:', surname)
                ИЛИ
name, surname = input(), input()
print('Имя:', name, 'Фамилия:', surname)
```
+ Множественное присваивание удобно использовать, когда нужно обменять значения двух переменных. В Python это делается так:
```
name1 = 'Timur'
name2 = 'Gvido'
name1, name2 = name2, name1
```
+ В качестве названия переменных запрещено использовать ключевые (зарезервированные) слова.
## 4. 
# Базовые типы данных.

[Оглавление](#oglavlenie)
## 4-1 
##  Целые числа.
int -  целые числа 

## 4-2
[Оглавление](#oglavlenie)
## Вещественные числа.
float - вещ. числа (разделитель является точка) - 3.1415
## 4-3 
[Оглавление](#oglavlenie)
## Логический тип.
bool - логический тип
## 4-4 
[Оглавление](#oglavlenie)
## Строчный тип.
str - строка
`Пример:`
 ```
n = 'hello'
```
+ Присвоить пустое значение (none)
`Пример:`
``` 
n = ""
n = None
print(n)
```
+ Для того чтобы понять какая переменная используется: `print(type(n))`
### 4-4-1
### Срезы в строках: 

[Оглавление](#oglavlenie)

Пример :
```
text = 'Съешь еще этих мягких французских булочек'
```
1.  `Переворот строки` :
```
n = Привет
m = n[::-1]
print(m)
```
2. `print(text[0])` - выдаст букву 'c'.

1. `print(text[-1])` - это отрицательная индексация выдаст букву 'к'.
1. `print(text[:])` - выводится весь текст.
1. `print(text[:4])` - это означает что мы хотим вывести с 0-го индекса до 4 `(не включая 4)`
1. `print(text[5:])` - это означает, что мы хотим вывести текст с 5 элемента и до конца. 
1. `print(text[0:len(text):6]` или `print(text[::6]` - после второго двоеточия мы указываем какой будет шаг, тут ознчает, что мы выводим текст с самого начала и до конца с шагом  6.   
1. Текст также можно `скаладывать` : 
```
text = 'Съешь еще этих мягких французских булочек'

text = text[2:9] + text[-5] + text[:2]
print(text)
```
тут мы `складываем` текст в дипозоне со второго элемента до 9 `с` элементом -5 `и с` диапозоном от 0 до 2.
```
Предположим, у нас есть строка s = 'abcdefghij' и мы хотим заменить символ с индексом 4 на 'X'. Можно попытаться написать код:

            s[4] = 'X'

Однако такой код не работает. В Python строки являются неизменяемыми, то есть мы не можем менять их содержимое с помощью индексатора.

Если мы хотим поменять какой-либо символ строки s, мы должны создать новую строку. Следующий код использует срезы и решает поставленную задачу:

        s = s[:4] + 'X' + s[5:]

Мы создаем два среза: от начала строки до 3 символа и с 5 символа по конец строки, а между ними вставляем нужный нам символ, который встанет на 4 позицию.
```

### 4-4-2
### Конкатенация строк.
[Оглавление](#oglavlenie)

Строки, как и числа, можно складывать. Операция сложения строк называется конкатенацией или сцеплением.

Рассмотрим следующий программный код:
```
s1 = 'ab' + 'bc'
s2 = 'bc' + 'ab'
s3 = s1 + s2 + '!!'
print(s1)
print(s2)
print(s3)
    Вывод: 
abbc
bcab
abbcbcab!!
```
### 4-4-3.
### Умножение строки на число.
[Оглавление](#oglavlenie)

В Python также можно умножать строку на число. Такой оператор повторяет строку указанное количество раз.

Рассмотрим следующий программный код:
```
s = 'Hi' * 4
print(s)
    Вывод:
HiHiHiHi
```
### 4-4-4. 
### Примечания.
[Оглавление](#oglavlenie)

`Примечание 1.` Тройные кавычки в Python используются для многострочного (multiline) текста. `Например`
```
text = '''Python is an interpreted, high-level, general-purpose programming language.
Created by Guido van Rossum and first released in 1991, Python design 
philosophy emphasizes code readability with its notable use of significant whitespace.'''
```
`Примечание 2.` На первый взгляд может показаться странным, что можно использовать как одинарные, так и двойные кавычки, однако такой подход позволяет очень легко добавлять в строку нужные кавычки:
```
s1 = 'Мы можем использовать в одиночных кавычках двойные кавычки "Война и мир"'
s2 = "Мы можем использовать в двойных кавычках одиночные кавычки 'Война и мир'"
print(s1)
print(s2)
```
# 4-4-5.
# Методы в строках.
[Оглавление](#oglavlenie)
+  Вывод количества элементов в сторке : 
```
text = 'Съешь еще этих мягких французских булочек'
print(len(text))
```
+ Есть ли определенная строка в строке `text` :
```
print('еще in text')
```
+ Метод — специализированная функция, тесно связанная с объектом. Как и функция, метод вызывается для выполнения отдельной задачи, но он вызывается для определенного объекта и “знает” о своем целевом объекте во время выполнения.

+ Таким образом: метод — функция, применяемая к объекту. В данном случае к строке. Метод вызывается в виде `имя_объекта.имя_метода(параметры).`

Например:  
```
s.find('e') — это применение к строке s метода find с одним параметром 'e'.
```
+ Методы строкового типа данных можно разделить на три группы:

1. Конвертация регистра;
2. Поиск и замена;
3. Классификация символов.

# 4-4-5-1 
# Конвертация регистра.
[Оглавление](#oglavlenie)
+ Методы в этой группе выполняют преобразование регистра для строк.
### 4-4-5-1-1
###  Метод `capitalize()`
[Оглавление](#oglavlenie)

+ `Метод capitalize()` возвращает `копию` строки s, в которой `первый` символ имеет `верхний регистр`, а все `остальные `символы имеют `нижний регистр.`

`Результатом` выполнения следующего кода`:`
```
s = 'foO BaR BAZ quX'
print(s.capitalize())
будет:

Foo bar baz qux
```
+ Символы, не являющиеся буквами алфавита, остаются неизменными. Результатом выполнения следующего кода:
```
s = 'foo123#BAR#.'
print(s.capitalize())

будет:
Foo123#bar#.
```
### 4-4-5-1-2
### Метод `swapcase()`
[Оглавление](#oglavlenie)

+ `Метод swapcase()` возвращает копию строки s, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот.

 Результатом выполнения следующего кода:
```
s = 'FOO Bar 123 baz qUX'
print(s.swapcase())
будет:

foo bAR 123 BAZ Qux
```

### 4-4-5-1-3
### Метод `title()`
[Оглавление](#oglavlenie)

+ `Метод title()` возвращает копию строки s, в которой первый символ каждого слова переводится в верхний регистр.

Результатом выполнения следующего кода:
```
s = 'the sun also rises'
print(s.title())
будет:

The Sun Also Rises
```
Этот метод использует довольно простой алгоритм: он не пытается различить важные и неважные слова и не обрабатывает аббревиатуры и апострофы.

 Результатом выполнения следующего кода:
```
s = "what's happened to ted's IBM stock?"
print(s.title())
будет:

What'S Happened To Ted'S Ibm Stock?
```
### 4-4-5-1-4
### Метод `lower()`
[Оглавление](#oglavlenie)

+ `Метод lower()` возвращает копию строки s, в которой все символы имеют нижний регистр.

Результатом выполнения следующего кода:
```
s = 'FOO Bar 123 baz qUX'
print(s.lower())
будет:

foo bar 123 baz qux
```
### 4-4-5-1-5
### Метод `upper()`
[Оглавление](#oglavlenie)

+ `Метод upper()` возвращает копию строки s, в которой все символы имеют верхний регистр.

Результатом выполнения следующего кода:
```
s = 'FOO Bar 123 baz qUX'
print(s.upper())
будет:

FOO BAR 123 BAZ QUX
```
### 4-4-5-1-6
### Примечание:
[Оглавление](#oglavlenie)
+ Одно очень важное замечание о методах данной категории состоит в том, что они не изменяют исходную строку. Если вы хотите изменить строку s нужно написать код: s = s.lower().

`Англо-русский словарик:`
+ capitalize — писать прописными буквами, закрепить.
+ swapcase — обменять регистр. swap — гл. обмениваться, case — случай, регистр, падеж, дело, расследование...
+ title — заголовок, титул.
+ lower — нижний.
+ upper — верхний.

# 4-4-5-2
# Поиск и замена
[Оглавление](#oglavlenie)

Методы поиска и замены строк внутри других строк.

+ Каждый метод в этой группе поддерживает необязательные аргументы `<start> и <end>.` Как и в строковых срезах действие метода ограничено частью исходной строки, начинающейся с позиции символа `<start>` и продолжающейся вплоть до позиции символа `<end>`, но не включающей ее. Если параметр `<start>` указан, а параметр `<end> `нет, то метод применяется к части исходной строки от `<start>` до конца строки. Если параметры не заданы, то подразумевается, что `<start> = 0 `, `<end> = len(s)`.
### 4-4-5-2-1
### Метод count()
[Оглавление](#oglavlenie)
+ Метод count`(<sub>, <start>, <end>) `считает количество непересекающихся вхождений подстроки `<sub>` в исходную строку `s.`

Результатом выполнения следующего кода:
```
s = 'foo goo moo'
print(s.count('oo'))
print(s.count('oo', 0, 8))  # подсчет с 0 по 7 символ
будет:

3
2
```
### 4-4-5-2-2
### Метод startswith()
[Оглавление](#oglavlenie)
+ Метод startswith`(<suffix>, <start>, <end>)` определяет начинается ли исходная строка `s` подстрокой `<suffix>`. Если исходная строка начинается с подстроки `<suffix>`,метод возвращает значение `True,` а если нет, то  `False`.

Результатом выполнения следующего кода:
```
s = 'foobar'
print(s.startswith('foo'))
print(s.startswith('baz'))
будет:

True
False
```
### 4-4-5-2-3
### Метод endswith()
[Оглавление](#oglavlenie)
+ Метод endswith`(<suffix>, <start>, <end>)` определяет оканчивается ли исходная строка `s` подстрокой `<suffix>.` Метод возвращает значение `True` если исходная строка оканчивается на подстроку `<suffix> `и `False` в противном случае.

Результатом выполнения следующего кода:
```
s = 'foobar'
print(s.endswith('bar'))
print(s.endswith('baz'))
будет:

True
False
```
### 4-4-5-2-4
### Методы find(), rfind()
[Оглавление](#oglavlenie)

+ Метод `find(<sub>, <start>, <end>)` находит индекс первого вхождения подстроки` <sub>` в исходной строке `s.` Если строка `s` не содержит подстроки` <sub>`, то метод возвращает значение `-1`. Мы можем использовать данный метод наравне с оператором `in` для проверки: содержит ли заданная строка некоторую подстроку или нет.

Результатом выполнения следующего кода:
```
s = 'foo bar foo baz foo qux'
print(s.find('foo'))
print(s.find('bar'))
print(s.find('qu'))
print(s.find('python'))
будет:

0
4
20
-1
```
+ Метод `rfind(<sub>, <start>, <end>)` идентичен методу `find(<sub>, <start>, <end>)`, за тем исключением, что он ищет первое вхождение подстроки `<sub>` начиная с конца строки `s.`

### 4-4-5-2-5
###  Методы index(), rindex()
[Оглавление](#oglavlenie)
+ Метод `index(<sub>, <start>, <end>)` идентичен методу `find(<sub>, <start>, <end>)`, за тем исключением, что он вызывает ошибку  `ValueError: substring not found` во время выполнения программы, если подстрока` <sub>` не найдена.

+ Метод `rindex(<sub>, <start>, <end>)` идентичен методу `index(<sub>, <start>, <end>)`, за тем исключением, что он ищет первое вхождение подстроки `<sub>` начиная с конца строки `s.`

+ Методы `find()` и `rfind()` являются более безопасными чем `index() и rindex()`, так как не приводят к возникновению ошибки во время выполнения программы.
### 4-4-5-2-6
### Метод strip()
[Оглавление](#oglavlenie)
+ Метод `strip()` возвращает копию строки `s` у которой удалены все пробелы стоящие в начале и конце строки.

Результатом выполнения следующего кода:
```
s = '     foo bar foo baz foo qux      '
print(s.strip())
будет:

foo bar foo baz foo qux
```

### 4-4-5-2-7
### Метод lstrip()
[Оглавление](#oglavlenie)
+ Метод `lstrip()` возвращает копию строки `s` у которой удалены все пробелы стоящие в начале строки.

Результатом выполнения следующего кода:
```
s = '     foo bar foo baz foo qux      '
print(s.lstrip())
будет:

foo bar foo baz foo qux⎵ ⎵ ⎵ ⎵ ⎵ ⎵
```
### 4-4-5-2-8
### Метод rstrip()
[Оглавление](#oglavlenie)
+ Метод `rstrip()` возвращает копию строки `s` у которой удалены все пробелы стоящие в конце строки.

Результатом выполнения следующего кода:
```
s = '      foo bar foo baz foo qux      '
print(s.rstrip())
будет:

⎵ ⎵ ⎵ ⎵ ⎵ ⎵foo bar foo baz foo qux
 ```

+ Методы `strip(), lstrip(), rstrip()` могут принимать на вход опциональный аргумент`<chars>`. Необязательный аргумент `<chars>`– это строка, которая определяет набор символов для удаления.

### 4-4-5-2-9
### Метод replace()
[Оглавление](#oglavlenie)
+ Метод `replace(<old>, <new>)` возвращает копию `s` со всеми вхождениями подстроки `<old>`, замененными на `<new>`.

Результатом выполнения следующего кода:
```
s = 'foo bar foo baz foo qux'
print(s.replace('foo', 'grault'))
будет:

grault bar grault baz grault qux
```
+ Метод `replace()` может принимать опциональный третий аргумент `<count>`,  который определяет количество замен.

Результатом выполнения следующего кода:
```
s = 'foo bar foo baz foo qux'
print(s.replace('foo', 'grault', 2))
будет:

grault bar grault baz foo qux
```
# 4-4-5-3
# Классификация символов
[Оглавление](#oglavlenie)
+ Методы в этой группе классифицируют строку на основе содержащихся в ней символов.
## 4-4-5-3-1 
## Метод isalnum()
[Оглавление](#oglavlenie)
+ `Метод isalnum()` определяет, состоит ли исходная строка из буквенно-цифровых символов. Метод возвращает значение `True` если исходная строка `является непустой` и состоит только из буквенно-цифровых символов и `False` в противном случае.

Результатом выполнения следующего кода:
```
s1 = 'abc123'
s2 = 'abc$*123'
s3 = ''

print(s1.isalnum())
print(s2.isalnum())
print(s3.isalnum())
будет:

True
False
False
```
## 4-4-5-3-2 
## Метод isalpha()
[Оглавление](#oglavlenie)
+ `Метод isalpha()` определяет, состоит ли исходная строка из буквенных символов. Метод возвращает значение `True` если исходная строка `является непустой` и состоит только из буквенных символов и `False` в противном случае.

Результатом выполнения следующего кода:
```
s1 = 'ABCabc'
s2 = 'abc123'
s3 = ''

print(s1.isalpha())
print(s2.isalpha())
print(s3.isalpha())
будет:

True
False
False
```
## 4-4-5-3-3 
## Метод isdigit()
[Оглавление](#oglavlenie)

+ `Метод isdigit()` определяет, состоит ли исходная строка `только` из `цифровых символов`. Метод возвращает значение `True` если исходная строка является непустой и состоит только из цифровых символов и `False` в противном случае.

Результатом выполнения следующего кода:
```
s1 = '1234567'
s2 = 'abc123'
s3 = ''

print(s1.isdigit())
print(s2.isdigit())
print(s3.isdigit())
будет:

True
False
False
```
## 4-4-5-3-4 
## Метод islower()
[Оглавление](#oglavlenie)
+ `Метод islower()` определяет, являются ли все `буквенные символы` исходной строки `строчными` (имеют нижний регистр). Метод возвращает значение `True` если все буквенные символы исходной строки являются строчными и `False` в противном случае. Все `неалфавитные` символы `игнорируются`!

Результатом выполнения следующего кода:
```
s1 = 'abc'
s2 = 'abc1$d'
s3 = 'Abc1$D'

print(s1.islower())
print(s2.islower())
print(s3.islower())
будет:

True
True
False
```
## 4-4-5-3-5 
## Метод isupper()
[Оглавление](#oglavlenie)

+ `Метод isupper()` определяет, являются ли все буквенные символы исходной строки заглавными (`имеют верхний регистр`). Метод возвращает значение `True` если все буквенные символы исходной строки являются заглавными и `Fals`e в противном случае. Все `неалфавитные` символы `игнорируются`!

Результатом выполнения следующего кода:
```
s1 = 'ABC'
s2 = 'ABC1$D'
s3 = 'Abc1$D'

print(s1.isupper())
print(s2.isupper())
print(s3.isupper())
будет:

True
True
False
```
## 4-4-5-3-6 
## Метод isspace()
[Оглавление](#oglavlenie)

+ `Метод isspace()` определяет, состоит ли исходная строка только из пробельных символов. Метод возвращает значение `True` если строка состоит только из пробельных символов и `False` в противном случае.

Результатом выполнения следующего кода:
```
s1 = '       '
s2 = 'abc1$d'

print(s1.isspace())
print(s2.isspace())
будет:

True
False
```
## 5. 
# Комментарии.
[Оглавление](#oglavlenie)

Чтобы закомитить сточку кода или несколько: 
+ В начале строки используем `#`.

+ Выделяем что мы хотим закомитить и делаем `cmd + k` далее `cmd + c` Всеь выделенный код будет закоммичен.
Чтобы убрать --> Выделяем текст и делаем `cmd + a` затем `cmd + u`. 
+ `"""` перед какой-то строчкой и `"""` после какой-то строчки. Результат закомичена определенная область.

## 6. 
# Интерпаляция.

[Оглавление](#oglavlenie)

Пример: У нас есть данные и нам нужно их вывести
```
a = 5
b = 5.89
c = 'hello'

print(f"{a} - {b} - {c}")
print("{0} - {1} - {2}".format(a,b,c)) 
```
## 7.
# Приведение типов.

[Оглавление](#oglavlenie)

`Пример 1:`

c = 5.89 - вещественное число, чтобы сделать из него целое, нужно:

```
n = int(c) `~ 5
``` 

Точно также и c дргуими типами данных. Есть исключения, но их не буду выписывать они все логичные.

Если мы говрим о `bool`, то `0` - это `false` и `1` - это `true` 

`Пример 2:` 

Чтобы получить от пользователя число: 

a = int(input('Введите число'))

`Пример 3 :`
+ `символ разделтель`

Для удобного чтения чисел можно использовать символ подчеркивания:
```
num1 = 25_000_000
num2 = 25000000
print(num1)
print(num2)

    ВЫВОД: 

        25000000
        25000000
```

## 8.
# Арифметические операции 

[Оглавление](#oglavlenie)
+ `+` - это сложение.
+ `-` - это вычитание. 
+ `*` - это умножение.
+ `/` - это деление (по умолчанию в вещ. числах).
+ `%` - это остаток от деления.
    + Если у нас делимое < делителя, то в остатке будет делимое. 
    + при нахождении остатка от деления на целое число `n` может получаться результат `0, 1, 2, ...n-1`, то есть к примеру при делении на `3` остатки `(0, 1, 2)`
    ```
    print(10 % 12)
    print(10 % 20)
        Вывод:
    10 
    10
    ```
+ `//` - это целочисленное деление.
    ```
    print(10 // 3)
    print(-10 // 3)
        Вывод:
    3   # округление в меньшую сторону
    -4  # округление в меньшую сторону
    ```
+ `**` - это возведение в степень.

1. `i = 2`
2. `i += 3` - это `i = i + 3`
3. `i -= 4` - это `i = i - 4`
4. `i *= 5` - это `i = i * 5`
5. `i /= 5` - это `i = i / 5`
6. `i //= 5` - это `i = i // 5`
7. `i %= 5` - это `i = i % 5`
8. `i **= 5` - это `i = i ** 5`

## 9.
# Алгоритм получения цифр n-значного числа :

[Оглавление](#oglavlenie)

Несложно понять, по какому алгоритму можно найти каждую цифру n-значного числа num:
+ Последняя цифра: (num % 10^1) // 10^0;
+ Предпоследняя цифра: (num % 10^2) // 10^1;
+ Предпредпоследняя цифра: (num % 10^3) // 10^2;
+ ...
+ Вторая цифра: (num % 10^n-1) // 10^n-2;
+ Первая цифра: (num % 10^n) // 10^n-1;

## 10. 
# Логические операции :

[Оглавление](#oglavlenie)
+ `>` - это `Больше`
+ `<` - это `Меньше` 
+ `>=` - это `Больше или равно`
+ `<=` - это `Меньше или равно`
+ `==` - это `Равно(проверяет, равны ли числа)`
+ `!=` - это `Не равно(проверяет, не равны ли значения)`
+ `not` - это `Не (отрицание)`
```
age = int(input('Сколько вам лет?: '))
if not (age < 12):
    print('Доступ разрешен.')
else:
    print('Доступ запрещен.')

    Полностью эквивалентен коду:

age = int(input('Сколько вам лет?: '))
if age >= 12:
    print('Доступ разрешен.')
else:
    print('Доступ запрещен.')
```
+ `and` - это `И (конъюнкция)`
+ `or` - это `Или (Дизъюнкция)`

## 10-1
[Оглавление](#oglavlenie)
## Приоритет логических операций. 
Логические операторы, подобно арифметическим операторам (+, -, *, /), имеют приоритет выполнения. Приоритет выполнения следующий:

+ `В первую очередь` выполняется логическое отрицание not;
+ `далее выполняется` логическое умножение and;
+ `далее выполняется` логическое сложение or.
Для явного указания порядка выполнения условных операторов используют скобки.

## 10-2 
## Цепочки сравнений:

[Оглавление](#oglavlenie)
```
age = int(input())
if 3 <= age <= 6:
    print('Вы ребёнок')
else: 
    print:('Вы не ребенок')
```
## 11.
 # Округление чисел: 

[Оглавление](#oglavlenie)

`Обычное округление :`

a = 5.89956

b = 6.556551

print`(round(a*b, 3))` - округление до 3 числа после запятой.

`Округление в большую сторону :`

import math

print(math.ceil(m / n)) 

## 12.
 # Управляющие конструкции: if, else, elif, while.

[Оглавление](#oglavlenie)

+ `if и else` - Это условия (если , иначе).

+ `elif` - Это сложные условия ,когда условий больше двух.
+ `while` - цикл позволяет выполнить блок кода пока условие является верным.

 `Пример:`

```
text = input()
total = 0
while text != 'stop':
    num = int(text)
    total += num
    text = input()
print('Сумма чисел равна', total)
```
+ `while - else` - Блок `else` выполняется когда тело цикла перестает работать самостоятельно.

`Пример :`
Напишем программу, которая определяет есть ли в числе цифра 7.
```
num = int(input())
has_seven = False  # сигнальная метка

while num != 0:
    last_digit = num % 10
    if last_digit == 7:
        has_seven = True
    num = num // 10

if has_seven == True:
    print('YES')
else:
    print('NO')
```
## 12-1
## Оператор прерывания цикла break.
[Оглавление](#oglavlenie)
+ Иногда бывает нужно прервать выполнение цикла преждевременно. Оператор break прерывает ближайший цикл for или while.
+ Оператор прерывания цикла break позволяет ускорять программы, так как мы избавляемся от лишних итераций.
+ Оператор прерывания цикла break удобен в связке с сигнальными метками: когда после проверки некоторого условия нам нет смысла продолжать выполнение цикла.

`Пример:` Напишем, программу, которая определяет, содержит ли введенное пользователем число, цифру 7.
```
num = int(input())
number = num
flag = False
while num != 0:
    last_digit = num % 10
    if last_digit == 7:
        flag = True
        break        # прерываем цикл, так как число гарантированно 
                        содержит цифру 7
    num //= 10

if flag == True:
    print('Число', number, 'содержит цифру 7')
else:
    print('Число', number, 'не содержит цифру 7')
```
## 12-2 
## Бесконечные циклы
[Оглавление](#oglavlenie)
```
while True:
    print('Python awesome!')
```
+ Бесконечный цикл продолжает повторяться до тех пор, пока программа не будет прервана. Изучив оператор break, мы получили механизм прерывания бесконечных циклов
## 12-3
## Оператор continue
[Оглавление](#oglavlenie)
+ Другая стандартная идиома циклов — пропуск отдельных элементов при переборе. Оператор continue позволяет перейти к следующей итерации цикла for или while до завершения всех команд в теле цикла.

`Напишем программу`, которая выводит все числа от `1 до 100`, кроме чисел `7, 17, 29 и 78.`
```
for i in range(1, 101):
    if i == 7 or i == 17 or i == 29 or i == 78:
        continue  # переходим на следующую итерацию
    print(i)
```
## 13. 
# Цикл for :

[Оглавление](#oglavlenie)

+ `for` - В Python цикл for в основном используется для перебора значений. 
    + Пример: 

    ```
    for i in range(1, 10, 2)
    ```
    где :
    + `Первое число - это` от какого значение начинается перебор. 

    + `Второе число - это` до какого значение идет перебор (не включая указанное число).
    + `Третье число - это` какой шаг будет использоваться для перебора значений(можно брать и отрицательное число, тогда будет уменьшаться). 
    + Если `указано` только `одно число` - это означает, что перебор будет выполняться `от 0 до заданного` числа `c шагом 1`.
## 13-1 
## Цикл for в строках.
 [Оглавление](#oglavlenie)
 + for можно использовать и со строками, так как у строк есть нумерация, такая же как и у массивов, начинается с 0: 
    + `Пример :` 
    ```
    for i in 'qwerty':
        print(i)

    Будет выводится каждая буква с новой строки. 
    ``` 

## Итерирование строк
+ Очень часто нужно просканировать всю строку целиком, обрабатывая каждый ее символ. Для этого удобно использовать цикл for. Напишем программу, которая выводит каждый символ строки на отдельной строке:
```
s = 'abcdef'
for i in range(len(s)):
    print(s[i])
```
## 14.

# Функции.
## 14-1.
## Функции min() и max().
[Оглавление](#oglavlenie)
+ Для определения соответственно минимального или максимального значения используются функции `min() и max().` Аргументов у этих функций может быть любое количество, главное, чтобы они все были одного типа.

`Например,` результатом выполнения следующего кода`:`
```
a = max(3, 8, -3, 12, 9)
b = min(3, 8, -3, 12, 9)
c = max(3.14, 2.17, 9.8)
print(a)
print(b)
print(c)
    Вывод :
    12
    -3
    9.8
```
## 14-2.
## Функция abs().
[Оглавление](#oglavlenie)
+ Для нахождения модуля (абсолютной величины) числа в Python используется    `функция abs().`

`Например,` результатом выполнения следующего кода:
```
print(abs(10))
print(abs(-7))
print(abs(0))
print(abs(-17.67))

        ВЫВОД :
10
7
0
17.67
```

`Первым` аргументом мы указываем какое слово хотим заменить, а `вторым` на какое слово хотим заменить.
## 14-3
## Модуль MATH
[Оглавление](#oglavlenie)
+ В Python модулем называется библиотека функций, которую можно подключать к своим программам.
+ Модуль math – один из наиважнейших в Python. Этот модуль предоставляет обширный функционал для проведения вычислений с вещественными числами (числами с плавающей точкой).

Для использования этих функций в начале программы необходимо подключить модуль, что делается командой import:
```
import math
```
+ После подключения модуля мы можем использовать его функции. Пусть мы хотим:

вычислить (корень квадратный из двух);
округлить число 3.8 до ближайшего целого числа вверх и вниз
Соответствующий программный код, решающий задачи выглядит так:
```
import math

num1 = math.sqrt(2)     # вычисление корня квадратного из двух
num2 = math.ceil(3.8)   # округление числа вверх
num3 = math.floor(3.8)  # округление числа вниз
```
+ Как можно заметить из примера выше, для вызова функции мы вынуждены указывать название модуля и символ точки. С другой стороны, если функции используются достаточно часто, то такой вызов (постоянное указание названия модуля и символа точки) может усложнить программу и сделать её менее читабельной. Для того, чтобы не указывать название модуля и символ точки при вызове функций, мы пишем следующий код:
```
from math import * ---> #  позволяет не писать название модуля и символ точки. При таком способе подключения, импортируются абсолютно все функции модуля math.

num1 = sqrt(2)     # вычисление корня квадратного из двух
num2 = ceil(3.8)   # округление числа вверх
num3 = floor(3.8)  # округление числа вниз
```
+ Если нужно использовать только некоторые функции модуля, то мы можем импортировать только их следующим образом:
```
from math import sqrt, ceil
```
### 14-3-1
### Список наиболее часто используемых функций модуля math:
[Оглавление](#oglavlenie)
```
Функция         	Описание
ОКРУГЛЕНИЯ

int()	    --->     Округляет число в сторону нуля

round(x)	--->    Округляет число x до ближайшего целого.     
                    Если дробная часть числа равна 0.5, то 
                    число округляется до ближайшего четного 
                    числа

round(x, n)	        Округляет число x до n знаков после точки

floor(x)    --->    Округляет число x вниз («пол»)
ceil(x)	    --->    Округляет число x вверх («потолок»)
abs(x)	    --->    Модуль числа x (абсолютная величина)

КОРНИ ЛОГАРИФМЫ СТЕПЕНИ ФАКТОРИАЛ

sqrt(x)	    --->    Квадратный корень числа x

pow(x, n)	--->    Возведение числа x в степень n

log(x)	    --->    Натуральный логарифм числа x. 
                    Основание натурального логарифма равно 
                    числу e

log10(x)	--->    Десятичный логарифм числа x. Основание 
                    десятичного логарифма равно числу 10

log(x, b)	--->    Логарифм числа x по основанию b

factorial(n) --->   Факториал натурального числа n

ТРИГОНОМЕТРИЯ

degrees(x)   --->   Преобразует угол x, заданный в 
                    радианах, в  градусы

radians(x)  --->    Преобразует угол x, заданный в 
                    градусах, в радианы

cos(x)    --->      Косинус угла x, задаваемого в радианах
sin(x)   --->       Синус угла x, задаваемого в радианах
tan(x)   --->       Тангенс угла x, задаваемого в радианах

acos(x) --->        Возвращает угол в радианах от 0 до П, 
                    cos которого равен x

asin(x)  --->       Возвращает угол в радианах от -(п/2) до 
                    п/2, sin которого равен x

atan(x)  --->       Возвращает угол в радианах от -(п/2) до 
                    п/2, tan которого равен x

atan2(y, x)  --->   Полярный угол (в радианах) точки с 
                    координатами (x, y)
```
`Примечания`
+  Для использования функций int(), float(), abs(), min(), max(), round() подключать модуль math нет необходимости. Это так называемые встроенные функции.
+ Вызов функций pow(x, n) можно заменить использованием оператора возведения в степень: x**n
+ Все функции модуля math возвращают значение, которое можно вывести на экран, присвоить другой переменной или использовать в математическом выражении.
## 14-4
## Модуль random
[Оглавление](#oglavlenie)
+ Модуль random предоставляет функции для генерации псевдослучайных чисел, букв и случайного выбора элементов последовательности (списка, строки и т.д.).

+ Для использования этих функций в начале программы необходимо подключить модуль, что делается командой import:
```
import random
```
+ После подключения модуля мы можем использовать его функции.

`Функция randint()`

Функция randint() принимает два обязательных аргумента a и b и возвращает псевдослучайное целое число из отрезка [a; b].
```
import random

num1 = random.randint(0, 17)
num2 = random.randint(-5, 5)

!!! Левая и правая граница ключаются в диапазон генерируемых псевдослучайных чисел !!!
```
## 15.
# Списки.
[Оглавление](#oglavlenie)

Список - это упорядоченный конечный набор элементов. Давайте разбираться, по
сути список - это тот же самый массив, в котором можно хранить элементы любых
типов данных.

+ Как работать со списками?
```
list_1 = [] - Создание пустого списка
list_2 = list() - Создание пустого списка
list_1 = [7, 9, 11, 13, 15, 17]

print(list_1) или print(*list_1) --> Разница в том, что 1-ый выводится со скобакми и запятыми, а второй выводится без всего, только с пробелом между элементами.
```
+ В списках существует нумерация, которая начинается с 0, чтобы вывести первый
элемент списка воспользуемся следующей конструкцией:
```
list_1 = [7, 9, 11, 13, 15, 17]
print(list_1[0]) --> 7
```
+ Чтобы узнать количество элементов в списке необходимо использовать функцию
len(имя_списка): 
```
list_1 = [7, 9, 11, 13, 15, 17]
print(len(list_1)) 
```
+ Можно список заполнять не только при его создание, но и во время работы
программы: 
```
list_1 = [] --> создание пустого списка
for i in range(5): --> цикл выполнится 5 раз
    n = int(input()) --> пользователь вводит целое число
    list_1.append(n) --> сохранение элемента в конец списка

1-я итерация цикла(повторение 1): n = 12, list_1 = [12]
2-я итерация цикла(повторение 2): n = 7, list_1 = [12, 7]
3-я итерация цикла(повторение 3): n = -1, list_1 = [12, 7, -1]
4-я итерация цикла(повторение 4): n = 21, list_1 = [12, 7, -1, 21]
5-я итерация цикла(повторение 5): n = 0, list_1 = [12, 7, -1, 21, 0]
print(list_1) # [12, 7, -1, 21, 0]
```

+ Мы обговорили с Вами создание списка и поняли, что мы можем пользоваться
нумерацией, для того чтобы узнать какой элемент стоит на той или иной позиции.
Но это не всегда удобно, особенно, когда список будет состоять из 1000, 1000000…
элементов. В этом случае необходимо использовать цикл for.
```
list_1 = [12, 7, -1, 21, 0]
for i in list_1:
print(i) --> вывод каждого элемента списка
            Не забываем, что у списка есть нумерация:
            print(list_1[i]) --> вывод каждого элемента списка
1-я итерация цикла(повторение 1): i = 12
2-я итерация цикла(повторение 2): i = 7
3-я итерация цикла(повторение 3): i = -1
4-я итерация цикла(повторение 4): i = 21
5-я итерация цикла(повторение 5): i = 0
```
## 15-1 
## Основные действия со списками:

[Оглавление](#oglavlenie)
 + Удаление последнего элемента списка.
 Метод pop удаляет последний элемент из списка:
 ```
list_1 = [12, 7, -1, 21, 0]

print(list_1.pop()) --> 0
print(list_1) --> [12, 7, -1, 21]
print(list_1.pop()) --> 21
print(list_1) --> [12, 7, -1]
print(list_1.pop()) --> -1
print(list_1) --> [12, 7]
```
+ Удаление конкретного элемента из списка.

Надо указать значение индекса в качестве аргумента функции pop:
```
list_1 = [12, 7, -1, 21, 0]
print(list_1.pop(0)) --> 12
print(list_1) --> [7, -1, 21, 0]
```
+ Добавление элемента на нужную позицию.

Функция insert — указание индекса (позиции) и значения.
```
list_1 = [12, 7, -1, 21, 0]

print(list1.insert(2, 11))
print(list1) --> [12, 7, 11, -1, 21, 0]
```
+ Срез списка:

Отрицательное число в индексе — счёт с конца списка.
```
list_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(list_1[0]) --> 1
print(list_1[1]) --> 2
print(list_1[len(list_1)-1]) --> 10
print(list_1[-5]) --> 6
print(list_1[:]) --> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(list_1[:2]) --> [1, 2]
print(list_1[len(list_1)-2:]) -->[9, 10]
print(list_1[2:9]) --> [3, 4, 5, 6, 7, 8, 9]
print(list_1[6:-18]) --> []
print(list_1[0:len(list_1):6]) --> [1, 7]
print(list_1[::6]) --> [1, 7]
```

## 16.
# Кортежи :

[Оглавление](#oglavlenie)

Кортеж — это неизменяемый список.

+ Тогда для чего нужны кортежи, если их нельзя изменить? В случае защиты
каких-либо данных от изменений (намеренных или случайных). Кортеж занимает
меньше места в памяти и работают быстрее, по сравнению со списками.
```
t = () --> создание пустого кортежа
print(type(t)) --> class <'tuple'>

t = (1,)
print(type(t)) --> class <'tuple'>

t = (1)
print(type(t)) --> class <'int'>

t = (28, 9, 1990)
print(type(t)) --> class <'tuple'>

colors = ['red', 'green', 'blue']
print(colors) --> ['red', 'green', 'blue']

t = tuple(colors)
print(t) --> ('red', 'green', 'blue')

t = tuple(['red', 'green', 'blue'])
print(t[0]) --> red
print(t[2]) --> blue

for e in t:
print(e) --> red green blue(на отдельных строках)

t[0] = 'black' --> TypeError: 'tuple' object does not support (нельзя изменять
кортеж)
```
+ Можно распаковать кортеж в независимые переменные:
```
t = tuple(['red', 'green', 'blue'])
red, green, blue = t
print('r:{} g:{} b:{}'.format(red, green, blue)) --> r:red g:green b:blue
```

## 17.
 # Словари.

[Оглавление](#oglavlenie)

Словари — неупорядоченные коллекции произвольных объектов с
доступом по ключу.
+ В списках в качестве ключа используется индекс элемента. В словаре для
определения элемента используется значение ключа (строка, число).
```
dictionary = {}
dictionary ={'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
print(dictionary) --> {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'}

print(dictionary['left']) --> ←
--> типы ключей могут отличаться

print(dictionary['up']) --> ↑
--> типы ключей могут отличаться

dictionary['left'] = '⇐'
print(dictionary['left']) --> ⇐

print(dictionary['type']) --> KeyError: 'type'

del dictionary['left'] --> удаление элемента

for item in dictionary: --> for (k,v) in dictionary.items():
    print('{}: {}'.format(item, dictionary[item]))
--> up: ↑
--> down: ↓
--> right: →
```

## 17-1
## Создание словаря с помощью функции dict()
[Оглавление](#oglavlenie)
+ Если ключи словаря — строки, без каких-либо специальных символов, то для создания словаря можно использовать функцию `dict()`

Код: 
```
info = dict(name = 'Timur', age = 28, job = 'Teacher')

Cоздает словарь с тремя элементами, ключами которого служат строки 'name', 'age', 'job', а значениями: 'Timur', 28, 'Teacher'
```
## 17-2 
## Создание словаря на основании списков и кортежей
[Оглавление](#oglavlenie)
+ Создавать словари можно на основе списков кортежей или кортежей списков. Первый элемент списка или кортежа станет ключом, второй — значением.
```
info_list = [('name', 'Timur'), ('age', 28), ('job', 'Teacher')]  # список кортежей

info_dict = dict(info_list)  # создаем словарь на основе списка кортежей
```
Аналогично работает приведенный ниже код: 
```
info_tuple = (['name', 'Timur'], ['age', 28], ['job', 'Teacher'])  # кортеж списков

info_dict = dict(info_tuple)  # создаем словарь на основе кортежа списков
```
## 17-3
## fromkeys()
[Оглавление](#oglavlenie)
+ Если необходимо создать словарь, каждому ключу которого соответствует одно и то же значение, можно воспользоваться методом
```
dict1 = dict.fromkeys(['name', 'age', 'job'], 'Missed information')

Cоздает словарь с тремя элементами, где ключи — строки 'name', 'age', 'job', а соответствующие им значения: 'Missed information', 'Missed information', 'Missed information'.
```
+ Если методу `fromkeys()` не передать второй параметр, то по умолчанию присваивается значение `None`

## 17-4 
## Пустой словарь
[Оглавление](#oglavlenie)

Пустой словарь можно создать двумя способами:

+ с помощью пустых фигурных скобок;
+ с помощью функции dict().

Приведенный ниже код:
```
dict1 = {}
dict2 = dict()


print(dict1)
print(dict2)
print(type(dict1))
print(type(dict2))
```
## 17-5
## Примечания
[Оглавление](#oglavlenie)

+ Примечание 1. Словари принципиально отличаются от списков по структуре хранения в памяти. Список — последовательная область памяти, то есть все его элементы (указатели на элементы) действительно хранятся в указанном порядке, расположены последовательно. Благодаря этому и можно быстро «прыгнуть» к элементу по его индексу. В словаре же используется специальная структура данных — хеш-таблица. Она позволяет вычислять числовой хеш от ключа и использовать обычные списки, где в качестве индекса элемента берется этот хеш.

+ Примечание 2. В рамках одного словаря каждый ключ уникален.

+ Примечание 3. Словари удобно использовать для хранения различных сущностей. Например, если нужно работать с информацией о человеке, то можно хранить все необходимые сведения, включающие такие разные сущности как "возраст", "профессия", "название города", "адрес электронной почты" в одном словаре  info и легко обращаться к его элементам по ключам:
```
info = {'name': 'Timur',
        'age': 28,
        'job': 'Teacher',
        'city': 'Moscow',
        'email': 'timyr-guev@yandex.ru'}

print(info['name'])
print(info['email'])
```
+ Что покажет результат выполнения приведенного ниже фрагмента кода?
```
my_dict = {1: [0, 1], 2: [2, 3], 3: [4, 5]}

print(my_dict[2][1])
```
Ответ: 3, т.к мы 1-ое обращаемся к словарю 2-ое мы обращаемся к ключу и 3-ье мы обращаемся по индоксу в значении.

## 17-6
## Ключи должны быть уникальными
[Оглавление](#oglavlenie)
+ Словарь не может иметь два и более значений по одному и тому же ключу. Если при создании словаря (в литеральной форме) указать дважды один и тот же ключ, будет использовано последнее из указанных значений.

Приведенный ниже код:
```
info = {'name': 'Ruslan',
        'age': 28,
        'name': 'Timur'}

print(info['name'])

выводит:
Timur
```
## 17-7
## Ключи должны быть неизменяемым типом данных
[Оглавление](#oglavlenie)

Ключом словаря могут быть данные любого неизменяемого типа:
+ число;
+ строка;
+ булево значение;
+ кортеж;
+ замороженное множество (frozenset);
+ ...

Приведенный ниже код создает словарь, ключами которого являются неизменяемые типы данных:
```
my_dict = {198: 'beegeek', 'name': 'Bob', True: 'a', (2, 2): 25}
```
Ключ словаря не может относиться к изменяемому типу данных:
+ список;
+ множество;
+ словарь;

Приведенный ниже код приводит к возникновению ошибки:
```
my_dict = {[2, 2]: 25, {1, 2}: 'python', 'name': 'Bob'}
```
## Значения могут относиться к любому типу данных, их тип данных произволен
+ Нет никаких ограничений для значений, хранящихся в словарях. Значения в словарях могут принадлежать к произвольному типу данных и повторяться для разных ключей многократно.
```
my_dict1 = {'a': [1, 2, 3], 'b': {1, 2, 3}}           # значения – изменяемый тип данных 

my_dict2 = {'a': [1, 2], 'b': [1, 2], 'c': [1, 2]}    # значения повторяются
```

## Основы работы со словарями
+ Работа со словарями похожа на работу со списками, поскольку и словари, и списки содержат в качестве отдельных элементов пары: в словарях `ключ: значение`, в списках `индекс: значение.` 
## 17-8
## Функция len()
[Оглавление](#oglavlenie)
+ Длиной словаря называется количество его элементов. Для определения длины словаря используют встроенную функцию len() (от слова length – длина).

Следующий программный код:
```
fruits = {'Apple': 70, 'Grape': 100, 'Banana': 80}
capitals = {'Россия': 'Москва', 'Франция': 'Париж'}

print(len(fruits))
print(len(capitals))

выведет:
3
2
```
## 17-9 
## Оператор принадлежности in
[Оглавление](#oglavlenie)

+ Оператор in позволяет проверить, содержит ли словарь заданный ключ.

Рассмотрим код:
```
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

if 'Франция' in capitals:
    print('Столица Франции - это', capitals['Франция'])
```
`Оператор принадлежности in на словарях работает очень быстро, намного быстрее, чем на списках, поэтому если нужен многократный поиск в коллекции данных, словарь – подходящий выбор.`

## 17-10 
## Встроенные функции sum(), min(), max()
[Оглавление](#oglavlenie)
+ Встроенная функция `sum()` принимает в качестве аргумента словарь с числовыми ключами и вычисляет сумму его ключей.

Следующий программный код:
```
my_dict = {10: 'Россия', 20: 'США', 30: 'Франция'}

print('Сумма всех ключей словаря =', sum(my_dict))

выводит:
Сумма всех ключей словаря = 60
```
`Для корректной работы функции sum() ключами словаря должны быть именно числа.`

+ Встроенные функции `min() и max()` принимают в качестве аргумента словарь и находят минимальный и максимальный ключ соответственно, при этом ключ может принадлежать к любому типу данных, для которого возможны операции порядка `<, <=, >, >= `(числа, строки, и т.д.). 

Следующий программный код:
```
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
months = {1: 'Январь', 2: 'Февраль', 3: 'Март'}

print('Минимальный ключ =', min(capitals))
print('Максимальный ключ =', max(months))

выводит:
Минимальный ключ = Россия
Максимальный ключ = 3
```
## 17-11
## Сравнение словарей
[Оглавление](#oglavlenie)
+ Словари можно сравнивать между собой. Равные словари имеют одинаковое количество элементов и содержат равные элементы (ключ: значение). Для сравнения словарей используются операторы `==` и `!=`

Приведенный ниже код:
```
months1 = {1: 'Январь', 2: 'Февраль'}
months2 = {1: 'Январь', 2: 'Февраль', 3: 'Март'}
months3 = {3: 'Март', 1: 'Январь', 2: 'Февраль'}

print(months1 == months2)
print(months2 == months3)
print(months1 != months3)

выводит:
False
True
True
```
## 17-12
## Примечание
[Оглавление](#oglavlenie)

+ Примечание 1. Обращение по индексу и срезы недоступны для словарей.

+ Примечание 2. Операция конкатенации `+` и умножения на число `*` недоступны для словарей.

+ Примечание 3. Словари нужно использовать в следующих случаях:

1. Подсчет числа каких-то объектов. В этом случае нужно завести словарь, в котором ключи — названия объектов, а значения — их количество.
2. Хранение каких-либо данных, связанных с объектом. Ключи — наименования объектов, значения — связанные с ними данные. Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря num = {'January': 1, 'February': 2, 'March': 3, ...}.
4. Установка соответствия между объектами (например, “родитель—потомок”). Ключ — объект, значение — соответствующий ему объект.
3. Если нужен обычный список, где максимальное значение индекса элемента очень велико, но при этом используются не все возможные индексы (так называемый “разреженный список”), то для экономии памяти можно использовать словарь.

## 18.
# Множества.

[Оглавление](#oglavlenie)

Множества содержат в себе уникальные элементы, не обязательно
упорядоченные.

+ Одно множество может содержать значения любых типов. Если у Вас есть два
множества, Вы можете совершать над ними любые стандартные операции,
например, объединение, пересечение и разность. Давайте разберем их.

```
colors = {'red', 'green', 'blue'}
print(colors) --> {'red', 'green', 'blue'}

colors.add('red')
print(colors) --> {'red', 'green', 'blue'}

colors.add('gray')
print(colors) --> {'red', 'green', 'blue','gray'}

colors.remove('red')
print(colors) --> {'green', 'blue','gray'}

colors.remove('red') --> KeyError: 'red' 

colors.discard('red') --> ok
print(colors) --> {'green', 'blue','gray'} (Проверка перед удалением)

colors.clear() --> { }
print(colors) --> set()
```
## 18-1 
## Операции со множествами в Python.

[Оглавление](#oglavlenie)
```
a = {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21}

c = a.copy() --> c = {1, 2, 3, 5, 8} (Копирование)

u = a.union(b) --> u = {1, 2, 3, 5, 8, 13, 21) (Объединение)

i = a.intersection(b) --> i = {8, 2, 5} (Пересечение)

dl = a.difference(b) --> dl = {1, 3} (Разница a - b)

dr = b.difference(a) --> dr = {13, 21} (Разнциа b - a)

q=a.union(b).difference(a.intersection(b)) --> {1, 21, 3, 13} (Сначала делаем пересечение множеств, затем объеденение множеств, затем разницу множеств)
```
+ `Неизменяемое` или `замороженное множество(frozenset)` — множество, с которым
не будут работать методы удаления и добавления.
```
a = {1, 2, 3, 5, 8}
b = frozenset(a)
print(b) --> frozenset({1, 2, 3, 5, 8})
```
## 18-2
## Обобщение свойств встроенных коллекций в сводной таблице :
[Оглавление](#oglavlenie)
<image src="/Users/danilbicikov/Desktop/Python/Коллекции.png" alt="Текст с описанием картинки">

## List Comprehension.
[Оглавление](#oglavlenie)
+ У каждого языка программирования есть свои особенности и преимущества. Одна
из культовых фишек Python — list comprehension (редко переводится на русский, но
можно использовать определение «генератора списка»). Comprehension легко
читать, и их используют как начинающие, так и опытные разработчики. 

List comprehension — это упрощенный подход к созданию списка, который
задействует цикл for, а также инструкции if-else для определения того, что в итоге
окажется в финальном списке.

1. Простая ситуация — список:
```
list_1 = [exp for item in iterable]
```
2. Выборка по заданному условию:
```
list_1 = [exp for item in iterable (if conditional)]
```

Задача: Создать список, состоящий из четных чисел в диапазоне от 1 до 100.

Решение:
1. Создать список чисел от 1 до 100: 
```
list_1 = []
for i in range(1, 101):
    list_1.append(i)
print(list_1) --> [1, 2, 3,..., 100]
```
Эту же функцию можно записать так :
```
list_1 = [i for i in range(1, 101)] --> [1, 2, 3,..., 100]
```
## 20.
# Примеры кода.
## 20-1.
## Подсчет количества.
[Оглавление](#oglavlenie)

+ Напишем программу, которая считывает 10 чисел и определяет сколько из них больше 10.
```
counter = 0
for i in range(10):
    num = int(input())
    if num > 10:
        counter = counter + 1
print('Было введено', counter, 'чисел, больших 10.')
```
## 20-2.
## Вычисление суммы и произведения.
[Оглавление](#oglavlenie)
+ Пример: напишем программу, которая запрашивает 10 целых чисел и находит их среднее значение:
```
total = 0
for i in range(10):
    num = int(input())
    total = total + num
average = total / 10
print('Среднее значение равно', average)
```
## 20-3.
## Обмен значений переменных
[Оглавление](#oglavlenie)
+ Такой код пишут почти во всех языках программирования. 
```
temp = x
x = y
y = temp
```
+ Однако в Python есть и более простой способ. Мы можем написать так: 
```
x, y = y, x
```
## 20-4.
## Сигнальные метки.
[Оглавление](#oglavlenie)
+ Напишем программу, определяющую, что натуральное число является простым:
```
num = int(input())
flag = True

for i in range(2, num):
    if num % i == 0:        #если исходное число делится на 
                            какое-либо отличное от 1 и самого себя
        flag = False

if num == 1:
    print('Это единица, она не простая и не составная') 
elif flag == True:
    print('Число простое')
else:
    print('Число составное')
```
## 20-5.
## Максимум и минимум.
[Оглавление](#oglavlenie)
```
largest = int(input())  # принимаем первое число за 
                        максимальное
for i in range(9):
    num = int(input())
    if num > largest:
        largest = num
print('Наибольшее число равно', largest)
```
